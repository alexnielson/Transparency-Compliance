---
title: "Batch Compliance Report"
author: "Michael Jensen"
date: "May 2019"
output: html_notebook
---
# Program Description

**Purpose**

For non-archived batches, check the following to determine whether a batch submitted by a local government or independent agency is compliant with Transparency reporting requirements:

* fiscal_year is one of the entity's most recent six fiscal years.
* type is 1, 2, 3, or 7 for non-State of Utah entities.
* posting_date corresponds to fiscal_year, meaning that posting_date is within the interval of one month prior to the start of the fiscal_year value through six months after the end of the fiscal_year value.
* account_number is populated with a number found in the OSA Uniform Chart of Accounts, meaning:
    * The account_number field contains a 17-digit code,
    * The first three digits are a valid fund code,
    * The next six digits are a valid function code,
    * The remaining eight digits are a valid account code, where the account code must match what is valid for the transaction type.

**Input(s)**

* The DSN for the ODBC to AWS.
* The DSN for the ODBC to Salesforce.

```{r}
dsn_aws        <- "transpAWS"
dsn_salesforce <- "Salesforce"
```

**Output(s)**

A .csv file that contains the following information for each invalid batch identified:

* Entity Salesforce ID
* Entity name
* Batch ID
* File name of the invalid batch
* Upload date
* Upload username
* Transaction types in the batch
* Beginning transaction date
* End transaction date
* File record count
* File total amount
* Message explaining the error, which is at least one of the following:
    * Invalid fiscal_year value
    * Invalid transaction type value
    * Invalid posting date
    * Number of blank or NA account_number values
    * Number of non-17 digit account_number values
    * Invalid fund codes used
    * Invalid function codes used
    * Invalid account codes used

# Libraries and Data Source(s)

```{r}
library(lubridate)
library(magrittr)
library(odbc)
library(readxl)
library(tidyverse)

odbc_aws <- dbConnect(odbc::odbc(), dsn_aws)
odbc_sf  <- dbConnect(odbc::odbc(), dsn_salesforce)

rm(dsn_aws, dsn_salesforce)

download.file(
  "http://financialreports.utah.gov/chartofaccounts/ChartofAccountFull.xlsx",
  "ucoa.xlsx",
  mode = "wb")
```

# Function Definitions

## Argument Definitions

```{r}
  #   batch_id (num): The batch's Transparency ID.
  #   begin_fy (Date): The first day of the entity's fiscal year.
  #   field_name (char): The name of the field to query.
  #   govt_type (char): The type of government (e.g., City).
  #   sf_id (char): The entity's Salesforce ID.
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #   ucoa (list): The list containing the Fund, Function, and Account codes 
  #     from OSA's Uniform Chart of Accounts.
```

## check_posting_date

```{r}
check_posting_date <- function(batch_id, begin_fy) {
  # Check a batch's posting_date values to determine whether they are reasonable.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #   begin_fy (Date): The first day of the entity's fiscal year.
  #
  # Value:
  #   Character.
  #
  # Comments:
  #   We consider the posting_date value to be reasonable if it is within one
  #   month prior to the start of the fiscal_year value through six months after
  #   the end of the fiscal_year value.
  #
  #   Thus, a posting_date value in the range of December 1, 2017 through
  #   June 30, 2019 is valid if the fiscal_year value is 2018 and the batch is
  #   from an entity with a fiscal year that begins on January 1.

  date_and_fy <- 
    dbGetQuery(
      odbc_aws,
      paste("
            SELECT DISTINCT posting_date, fiscal_year
            FROM transaction
            WHERE batch_id = ", batch_id)) %>% 
    mutate(fiscal_year = as.numeric(.[["fiscal_year"]]),
           begin_fy    = !!begin_fy)
  
  # Ensure begin_fy matches fiscal_year:
  if (month(begin_fy) == 1) {
    
    year(date_and_fy$begin_fy) <- date_and_fy$fiscal_year
    
  } else {
    
    year(date_and_fy$begin_fy) <- date_and_fy$fiscal_year - 1
  }
  
  date_and_fy$interval <- 
    (date_and_fy$begin_fy - months(1)) %--% 
    (date_and_fy$begin_fy + months(18) - 1)
  
  if (all(date_and_fy$posting_date %within% date_and_fy$interval)) {
    
    ""
    
  } else {
    
    "Posting Date seems unreasonable"
  }
}
```

## check_ucoa

```{r}
check_ucoa <- function(batch_id, govt_type, ucoa) {
  # Check whether a batch has valid Uniform Chart of Accounts codes.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #   govt_type (char): The type of government (e.g., City).
  #   ucoa (list): The list containing OSA's Uniform Chart of Accounts Fund,
  #     Function, and Account codes.
  #
  # Value:
  #   Tibble.
  #
  # Comments:
  #   Because we do not require entities to upload Balance Sheet data (type 7 
  #   transactions), I decided to not check those batches for valid UCoA codes.
  
  ucoa_reported <-
    dbGetQuery(
      odbc_aws,
      paste("
            SELECT DISTINCT type, account_number
            FROM transaction
            WHERE batch_id = ", batch_id)) %>% 
    mutate(account_number = str_remove_all(account_number, "-")) %>% 
    as_tibble()

  invalid_ucoa_info <- 
    tibble(
      batch_id            = batch_id,
      number_blank_or_na  = NA,
      non_17_digit        = NA,
      invalid_fund        = NA,
      invalid_funct       = NA,
      invalid_account_exp = NA,
      invalid_account_rev = NA,
      invalid_account_w2  = NA)
  
  if (govt_type == "School_District_or_Charter_School") {
    
    return(invalid_ucoa_info)
  }
  
  if (any(is.na(ucoa_reported$account_number)) || 
      any(ucoa_reported$account_number == "")) {
    
    invalid_ucoa_info$number_blank_or_na <- 
      ucoa_reported %>% 
      filter(account_number == "" | is.na(account_number)) %>% 
      nrow()
    
    ucoa_reported <- 
      ucoa_reported %>% 
      filter(account_number != "", !is.na(account_number))
  }
  
  if (any(nchar(ucoa_reported$account_number) != 17)) {
    
    invalid_ucoa_info$non_17_digit <- 
      ucoa_reported %>% 
      filter(nchar(account_number) != 17) %>% 
      .[["account_number"]] %>% 
      paste(collapse = ", ") %>% 
      sort()
    
    ucoa_reported <- 
      ucoa_reported %>% 
      filter(nchar(account_number) == 17)
  }
  
  fund <- 
    ucoa_reported %>% 
    .[["account_number"]] %>% 
    substring(1, 3)
  
  funct <-
    ucoa_reported %>% 
    .[["account_number"]] %>% 
    substring(4, 9)
  
  account <- 
    ucoa_reported %>% 
    mutate(account_number = substring(account_number, 10, 17))
  
  account_exp <- 
    account %>% 
    filter(type == 1) %>% 
    .[["account_number"]]
    
  account_rev <- 
    account %>%
    filter(type == 2) %>% 
    .[["account_number"]]
  
  account_w2 <- 
    account %>%
    filter(type == 3) %>% 
    .[["account_number"]]
  
  if (!all(fund %in% ucoa[["fund"]][["NUMBER"]])) {
    
    invalid_ucoa_info$invalid_fund <- 
      fund[!fund %in% ucoa[["fund"]][["NUMBER"]]] %>% 
      unique() %>% 
      paste(collapse = ", ") %>% 
      sort()
  }
  
  if (!all(funct %in% ucoa[["funct"]][["NUMBER"]])) {
    
    invalid_ucoa_info$invalid_funct <- 
      funct[!funct %in% ucoa[["funct"]][["NUMBER"]]] %>% 
      unique() %>% 
      paste(collapse = ", ") %>%
      sort()
  }
  
  if (!all(account_exp %in% ucoa[["account_exp"]][["NUMBER"]])) {
    
    invalid_ucoa_info$invalid_account_exp <- 
      account_exp[!account_exp %in% ucoa[["account_exp"]][["NUMBER"]]] %>% 
      unique() %>%
      paste(collapse = ", ") %>%
      sort()
  }
  
  if (!all(account_rev %in% ucoa[["account_rev"]][["NUMBER"]])) {
    
    invalid_ucoa_info$invalid_account_rev <- 
      account_exp[!account_rev %in% ucoa[["account_rev"]][["NUMBER"]]] %>% 
      unique() %>%
      paste(collapse = ", ") %>% 
      sort()
  }
  
  if (!all(account_w2 %in% ucoa[["account_w2"]][["NUMBER"]])) {
    
    invalid_ucoa_info$invalid_account_w2 <- 
      account_w2[!account_w2 %in% ucoa[["account_w2"]][["NUMBER"]]] %>% 
      unique() %>%
      paste(collapse = ", ") %>% 
      sort()
  }
  
  invalid_ucoa_info
}
```

## generate_report

```{r}
generate_report <- function(t_id, begin_fy, govt_type, name, sf_id, ucoa) {
  # Generate the batch compliance report for an entity.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #   begin_fy (Date): The first day of the entity's fiscal year.
  #   govt_type (char): The type of government (e.g., City).
  #   name: The entity's name.
  #   sf_id: The entity's Salesforce ID.
  #   ucoa (list): The list containing OSA's Uniform Chart of Accounts Fund,
  #     Function, and Account codes.
  #
  # Value:
  #   Tibble.
  
  batch_ids <- 
    query_batch_ids(t_id)
  
  if (nrow(batch_ids) == 0) {
    
    report <-
      tibble(
        batch_id             = NA,
        number_blank_or_na   = NA,
        non_17_digit         = NA,
        invalid_fund         = NA,
        invalid_funct        = NA,
        invalid_account_exp  = NA,
        invalid_account_rev  = NA,
        invalid_account_w2   = NA,
        invalid_date         = NA,
        entity_name          = NA,
        sf_id                = NA,
        upload_date          = NA,
        begin_txn_date       = NA,
        end_txn_date         = NA,
        transaction_type     = NA,
        username             = NA,
        uploaded_file        = NA,
        file_record_count    = NA,
        file_total_amount    = NA)
    
    return(report)
  }
  
  report <-
    batch_ids$batch_id %>% 
    map(check_ucoa, govt_type, ucoa) %>% 
    bind_rows()   %>% 
    mutate(invalid_date = map(batch_id, check_posting_date, begin_fy),
           entity_name  = !!name,
           sf_id        = !!sf_id) %>% 
    unnest(invalid_date)

 #  invalid_date <- 
 #    batch_ids$batch_id %>% 
 #    map(check_posting_date, begin_fy) %>% 
 #    bind_rows()
 #  
 #  invalid_ucoa <- 
 #    batch_ids$batch_id %>% 
 #    map(check_ucoa, ucoa) %>% 
 #    bind_rows()
 #  
 # report <- 
 #    invalid_ucoa %>% 
 #    left_join(invalid_date, by = "batch_id")
  
  report <- 
    report %>% 
    filter(
      !is.na(number_blank_or_na)  |
      !is.na(non_17_digit)        |
      !is.na(invalid_fund)        |
      !is.na(invalid_funct)       |
      !is.na(invalid_account_exp) |
      !is.na(invalid_account_exp) |
      !is.na(invalid_account_exp) |
      !is.na(invalid_date)) %>% 
    mutate(
      transaction_type    = map(batch_id, query_type),
      upload_date         = map(batch_id, query_date_field, "upload_date"),
      begin_txn_date      = map(batch_id, query_date_field, "begin_txn_date"),
      end_txn_date        = map(batch_id, query_date_field, "end_txn_date"),
      username            = map(batch_id, query_username),
      uploaded_file       = map(batch_id, query_file_name),
      file_record_count   = map(batch_id, 
                                query_batch_field, 
                                "file_record_count"),
      file_total_amount   = map(batch_id, 
                                query_batch_field, 
                                "file_total_amount"),
      entity_name         = name,
      entity_id           = sf_id) %>%
    unnest(upload_date, begin_txn_date, end_txn_date, transaction_type,
           username, uploaded_file, file_record_count, file_total_amount)
}
```

## query_batch_ids

```{r}
query_batch_ids <- function(t_id) {
  # Query an entity's processed batch IDs.
  #
  # Arguments:
  #   t_id (num): The entity's Transparency ID, as queried from Salesforce
  #     rather than Transparency.
  #
  # Value:
  #   Tibble.
  #
  # Comments:
  #   The 'DONTDELETE' batch status is a variation of 'PROCESSED.' DONTDELETE 
  #   indicates the data in the batch has been split among multiple transaction
  #   tables, as the batch contains data from a fiscal year that has been 
  #   archived.
  
  if (is.na(t_id)) {
    
    return(vector(mode = "numeric", length = 0)) 
  }
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT id
          FROM batch
          WHERE entity_id = ", t_id, "
          AND status IN ('PROCESSED', 'DONTDELETE')")) %>% 
    as_tibble() %>% 
    rename("batch_id" = "id")
}
```

## query_file_name

```{r}
query_file_name <- function(batch_id) {
  # Query the file name of an uploaded batch.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #
  # Value:
  #   Character.
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT upload_file
          FROM batch
          WHERE id = ", batch_id)) %>%
    .[["upload_file"]]
}
```

## query_date_field

```{r}
query_date_field <- function(batch_id, field_name) {
  # Query one of a batch's date fields (e.g., upload_date).
  #
  # Arguments:
  #   field_name (char): The name of the field to query.
  #   batch_id (num): The batch's Transparency ID.
  #
  # Value:
  #   Date.
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT ", field_name, " AS date_field
          FROM batch
          WHERE id = ", batch_id)) %>%
    .[["date_field"]] %>% 
    as.Date()
}
```

## query_type

```{r}
query_type <- function(batch_id) {
  # Query the transaction types contained in a batch.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #
  # Value:
  #   Character.
  
  reported_types <- 
    dbGetQuery(
      odbc_aws,
      paste("
            SELECT DISTINCT type
            FROM transaction
            WHERE batch_id = ", batch_id))
  
  reported_types$name <- 
    if_else(
      reported_types$type == 1,
      "EXP",
      if_else(
        reported_types$type == 2,
        "REV",
        if_else(
          reported_types$type == 3,
          "PAYROLL",
          if_else(
            reported_types$type == 7,
            "BS",
            "OTHER"))))
  
  reported_types$name %>% 
    paste(collapse = ", ")
}
```

## query_batch_field

```{r}
query_batch_field <- function(batch_id, field_name) {
  # Query a non-date field from the Batch Table.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #   field_name (char): The name of the field to query.
  #
  # Value:
  #   Character or numeric.
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT ", field_name, " AS field_name
          FROM batch
          WHERE id = ", batch_id)) %>% 
    .[["field_name"]]
}
```

## query_username

```{r}
query_username <- function(batch_id) {
  # Query the username of the person who uploaded a batch.
  #
  # Arguments:
  #   batch_id (num): The batch's Transparency ID.
  #
  # Value:
  #   Character.
  
  dbGetQuery(
    odbc_aws,
    paste("
          SELECT upload_username
          FROM batch
          WHERE id = ", batch_id)) %>%
    .[["upload_username"]]
}
```

# Execution

## Salesforce

### Import

```{r}
sf_data <-
  dbGetQuery(
    odbc_sf,
    paste("
          SELECT
            Account.Name                  AS name,
            Account.Id                    AS id,
            Account.Transparency_ID__c    AS t_id,
            Account.Fiscal_Year_Begins__c AS begin_fy,
            RecordType.DeveloperName      AS govt_type
          FROM Account
          JOIN RecordType
          ON Account.RecordTypeId = RecordType.Id
          WHERE Account.RecordTypeId IN (
            SELECT Id
            FROM RecordType
            WHERE DeveloperName IN (
            'AOG',
            'City',
            'Conservation_District',
            'County',
            'District_Health',
            'Housing',
            'Independent_Quasi_State_Entity',
            'Interlocal',
            'Local_and_Special_Service_District',
            'Mental_Health',
            'Redevelopment_Agency_Project_Area',
            'School_District_or_Charter_School',
            'Town'))
          AND Account.Entity_Status__c IN (
            'Current',
            'On hold',
            'Delinquent',
            'Suspended')
          AND Account.Name NOT IN (
            'Intermountain Power Agency',
            'Utah Associated Municipal Power Systems',
            'Utah Municipal Power Agency')
          AND (
            Account.Expense_Revenue_Start_Date__c <= DATE() OR
            Account.Expense_Revenue_Start_Date__c IS NULL)")) %>%
  as_tibble()

# Included in the above query.
# sf_independent_agency <-
#   dbGetQuery(
#     odbc_sf,
#     paste("
#           SELECT
#             Name                          AS name,
#             Id                            AS id,
#             Transparency_ID__c            AS t_id,
#             Fiscal_Year_Begins__c         AS begin_fy
#           FROM Account
#           WHERE RecordTypeId IN (
#             SELECT Id
#             FROM RecordType
#             WHERE DeveloperName IN (
#             'Independent_Quasi_State_Entity'))
#           AND Entity_Status__c IN (
#             'Current',
#             'On hold',
#             'Delinquent',
#             'Suspended')
#           AND (
#             Expense_Revenue_Start_Date__c <= DATE() OR
#             Expense_Revenue_Start_Date__c IS NULL)")) %>%
#   as_tibble()
```

## UCoA

```{r}
ucoa_fund <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[1]])

ucoa_function <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[2]])

ucoa_account <- 
  read_xlsx("ucoa.xlsx", sheet = excel_sheets("ucoa.xlsx")[[3]])

# Some of the code below will become unnecessary after I edit OSA's Uniform
# Chart of Accounts and publish it on the OSA website.

colnames(ucoa_fund)     <- ucoa_fund[2, ]
colnames(ucoa_function) <- c("NUMBER", ucoa_function[1, 2:4])
colnames(ucoa_account)  <- ucoa_account[2, ]

ucoa_fund     <- ucoa_fund %>% slice(-1, -2)
ucoa_function <- ucoa_function %>% slice(-1)
ucoa_account  <- ucoa_account %>% slice(-1, -2)

extra_fund_numbers <- 
  c(202:298, 302:398, 402:448, 452:498, 502:598, 602:698, 702:798) %>% 
  as.character() %>% 
  enframe(name = NULL) %>% 
  rename("NUMBER" = "value") %>% 
  mutate("SHORT DESCRIPTION" = NA, "FULL DESCRIPTION" = NA, "DETAIL" = NA)

ucoa_fund <- 
  ucoa_fund %>% 
  bind_rows(extra_fund_numbers)

ucoa_fund$NUMBER[[1]]     <- "010"
ucoa_fund$NUMBER[[2]]     <- "020"
ucoa_fund$NUMBER[[3]]     <- "030"
ucoa_function$NUMBER[[1]] <- "000000"

ucoa_account_exp <-
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^4"))

ucoa_account_rev <- 
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^3"))
  
ucoa_account_w2 <- 
  ucoa_account %>% 
  filter(str_detect(NUMBER, "^4001"))

ucoa <-
  list(
    fund        = ucoa_fund,
    funct       = ucoa_function,
    account     = ucoa_account,
    account_exp = ucoa_account_exp,
    account_rev = ucoa_account_rev,
    account_w2  = ucoa_account_w2)

rm(ucoa_fund, ucoa_function, ucoa_account, extra_fund_numbers, ucoa_account_exp,
   ucoa_account_rev, ucoa_account_w2)
```

## Report

```{r}
# Check fiscal_year:
invalid_fy <- 
  dbGetQuery(
    odbc_aws,
    "
    SELECT DISTINCT fiscal_year
    FROM transaction
    WHERE fiscal_year NOT IN (
      YEAR(CURDATE()), 
      YEAR(CURDATE()) - 1,
      YEAR(CURDATE()) - 2,
      YEAR(CURDATE()) - 3,
      YEAR(CURDATE()) - 4)")

# Check type:
invalid_type <- 
  dbGetQuery(
    odbc_aws,
    "
    SELECT DISTINCT
      batch.entity_id,
      transaction.type
    FROM transaction
    JOIN batch
    ON batch.id = transaction.batch_id
    WHERE transaction.type NOT IN (1, 2, 3, 7)
    AND batch.entity_id <> 1")

# Check posting_date and account_number
sf_data <- 
  sf_data %>% 
  filter(!is.na(t_id))

entity_batches <- 
  list(
    t_id      = as.list(sf_data$t_id),
    begin_fy  = as.list(sf_data$begin_fy),
    govt_type = as.list(sf_data$govt_type),
    name      = as.list(sf_data$name),
    sf_id     = as.list(sf_data$id)) %>% 
  pmap(generate_report, ucoa)

names(entity_batches) <- sf_data$name

report <- 
  entity_batches %>% 
  bind_rows() %>% 
  select(entity_name, batch_id, uploaded_file, upload_date, transaction_type,
         begin_txn_date, end_txn_date, file_record_count, file_total_amount, 
         number_blank_or_na, non_17_digit, invalid_fund, invalid_funct, 
         invalid_account_exp, invalid_account_rev, invalid_account_w2, 
         invalid_date, entity_id, username)
```

# DBMS Disconnection

```{r}
dbDisconnect()
```