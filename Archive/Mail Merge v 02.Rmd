---
title: "Mail Merge v 2.0"
author: "Michael Jensen"
date: "August 2019"
output: html_notebook
---
# Program Description

**Purpose**

Compile and format the information needed to send the 60-day Warning postcards or the Hold/Suspend Notices to local governments that are non-compliant with OSA or State Treasurer reporting requirements.

*This R program is based on Alexandra Nelson's "MailMerge Script, which is filed in S:\Localgov\LG Compliance\Compliance\Noncompliance Correspondence"*

**Input(s)**

```{r}
dsn_salesforce <- "Salesforce"

# Select the appropriate notice type:
notice_type <- 
  "60_day_notice"
  # "hold_or_suspend"

# Load the Missing D&I Report, which comes from the Office of the State 
# Treasurer (2019-08-12: The report came in three separate formats, and so 
# Brook thought it would be easier for her to manually enter the missing 
# reports than for me to wrangle the data and import it. Hopefully the State Treasurer's Office will figure out a better way to track the reports and send us
# a single .csv file next time):

```

**Output(s)**

A .csv file containing a record for each entity that is missing a required report, with the following fields:

* Entity name
* Entity CFO name
* Entity CAO name
* Entity address information
* A field for each report an entity is missing

# Libraries and Data Sources

```{r}
library(data.table)
library(magrittr)
library(odbc)
library(readxl)
library(splitstackshape)
library(svDialogs)
library(tidyverse)

odbc_salesforce <- dbConnect(odbc::odbc(), dsn_salesforce)
rm(dsn_salesforce)
```

# Function Definitions

## Argument Definitions

```{r, eval=FALSE}
  # Arguments:
  #  address_one (char): The portion of the complete address corresponding to 
  #    street_one.
  #  address_two (char):The portion of the complete address corresponding to 
  #    street_two.
  #  street_one (char): The default street address.
  #  street_two (char): The street address to compare against.
```

## find_an_address()

```{r}
find_an_address <- function(street_one, street_two, address_one, address_two) {
  # Compare two street addresses and select the corresponding address 
  # information for the street address that is not NA.
  #
  # Arguments:
  #  street_one (char): The default street address.
  #  street_two (char): The street address to compare against.
  #  address_one (char): The portion of the complete address corresponding to 
  #    street_one.
  #  address_two (char):The portion of the complete address corresponding to 
  #    street_two.
  #
  # Returns:
  #   Character.
  
  if (is.na(street_one) && !is.na(street_two)) {
    
    address_two
  
  } else {address_one}
}
```

# Execution

## Contact Information

```{r}
account <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT 
      a.Id                       AS sf_id,
      a.Name                     AS entity_name, 
      r.Name                     AS record_type,
      Is_Solely_Fee_Assessing__c AS non_taxing_entity,
      ShippingStreet, ShippingCity, ShippingState, ShippingPostalCode,
      BillingStreet, BillingCity, BillingState, BillingPostalCode
    FROM Account AS a
    JOIN RecordType AS r
    ON a.RecordTypeId = r.Id
    WHERE IsDeleted = FALSE
    AND Entity_Status__c NOT IN ('Inactive', 'Dissolved')
    AND a.Name <> 'test city 2'
    AND RecordTypeId IN (
      SELECT id
      FROM RecordType
      WHERE Name IN (
        'AOG', 'City', 'Community Reinvestment Agency', 'Conservation District',
        'County', 'District Health', 'Housing', 
        'Independent/Quasi State Entity', 'Interlocal', 
        'Local and Special Service District', 'Mental Health', 
        'Redevelopment Agency/Project Area', 
        'School District or Charter School', 'Town'))") %>% 
  mutate(street = pmap_chr(
                    list(
                      street_one  = as.list(ShippingStreet),
                      street_two  = as.list(BillingStreet),
                      address_one = as.list(ShippingStreet),
                      address_two = as.list(BillingStreet)),
                    find_an_address),
         city   = pmap_chr(
                    list(
                      street_one  = as.list(ShippingStreet),
                      street_two  = as.list(BillingStreet),
                      address_one = as.list(ShippingCity),
                      address_two = as.list(BillingCity)),
                    find_an_address),    
         state   = pmap_chr(
                    list(
                      street_one  = as.list(ShippingStreet),
                      street_two  = as.list(BillingStreet),
                      address_one = as.list(ShippingState),
                      address_two = as.list(BillingState)),
                    find_an_address),         
         zip     = pmap_chr(
                    list(
                      street_one  = as.list(ShippingStreet),
                      street_two  = as.list(BillingStreet),
                      address_one = as.list(ShippingPostalCode),
                      address_two = as.list(BillingPostalCode)),
                    find_an_address)) %>% 
  select(sf_id, entity_name, record_type, non_taxing_entity, 
         street, city, state, zip)

# CFOs and CAOs sometimes have an address that is different from the entity's
# address. Though it would be more convenient for the CFO and CAO to receive the 
# notice at the address specific to their contact information, I decided to 
# send notices to the entity address. Given that the CFO and CAO can change 
# without notifying OSA, it seems that sending the notice to the entity's 
# address is the best way to make sure that someone within the entity 
# organization will see it.

cfo <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT
      a.Name            AS entity_name, 
      c.Name            AS cfo_name
      -- MailingStreet     AS cfo_street, 
      -- MailingCity       AS cfo_city, 
      -- MailingState      AS cfo_state, 
     --  MailingPostalCode AS cfo_zipcode
    FROM Contact AS c
    JOIN Account AS a
    ON c.AccountId = a.Id
    WHERE c.IsDeleted = FALSE
    AND c.IsDeactivated__c = FALSE
    AND Role__c = 'CFO'")

cao <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT
      a.Name            AS entity_name, 
      c.Name            AS cao_name
      -- MailingStreet     AS cao_street, 
      -- MailingCity       AS cao_city, 
      -- MailingState      AS cao_state, 
      -- MailingPostalCode AS cao_zipcode
    FROM Contact AS c
    JOIN Account AS a
    ON c.AccountId = a.Id
    WHERE c.IsDeleted = FALSE
    AND c.IsDeactivated__c = FALSE
    AND Role__c = 'CAO'")

# Check for entities with multiple CFOs:
multiple_cfos <- 
  cfo[duplicated(cfo$entity_name), "entity_name"] %>% 
  tibble()

multiple_caos <- 
  cao[duplicated(cao$entity_name), "entity_name"] %>% 
  tibble()

if (nrow(multiple_cfos) > 0 || nrow(multiple_caos) > 0) {
  
  dlg_message(
  "Salesforce has at least one entity with multiple CFOs or CAOs.
  This program will select only one of the names to send a notice to.")
  
  cfo <- 
    cfo %>% 
    data.table() %>% 
    unique(by = "entity_name")

  cao <- 
    cao %>% 
    data.table() %>% 
    unique(by = "entity_name")
}

contact_info <- 
  account %>% 
  left_join(cfo, by = "entity_name") %>% 
  left_join(cao, by = "entity_name") %>% 
  mutate(cfo_name = if_else(is.na(cfo_name), "CFO", cfo_name),
         cao_name = if_else(is.na(cao_name), "CAO", cao_name))
```

## Missing Auditor Reports

```{r}
report_year <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT 
      Name as report_year, Id
    FROM Report_Year__c
    WHERE IsDeleted = FALSE
    AND Delinquent_Reports__c > 0")

reports__c <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT
      a.Name AS entity_name, r.Name as report_name, Report_Status__c
    FROM Reports__c AS r
    JOIN Account AS a
    ON r.Account__c = a.Id
    WHERE r.IsDeleted = FALSE
    AND Delinquent__c = TRUE
    AND Required__c = TRUE
    AND r.Name NOT IN ('Approved Budget', 'Ammended Budget')
    AND r.Entity_Type__c IN (
      SELECT Name
      FROM RecordType
      WHERE Name IN (
        'AOG', 'City', 'Community Reinvestment Agency', 'Conservation District',
        'County', 'District Health', 'Housing', 'Independent/Quasi State Entity',
        'Institution of Higher Education', 'Interlocal', 
        'Local and Special Service District', 'Mental Health', 'Non Profits', 
        'Redevelopment Agency/Project Area', 'School District or Charter School',
        'Town'))")

missing_reports_osa <- 
  reports__c %>% 
  left_join(report_year, by = c("Report_Status__c" = "Id")) %>% 
  unite(missing_report, report_year, report_name, sep = " ") %>% 
  select(-Report_Status__c)

missing_reports_osa <- 
  missing_reports_osa %>% 
  group_by(missing_report) %>% 
  summarize(n = n()) %>% 
  rowid_to_column("report_id") %>% 
  select(-n) %>% 
  right_join(missing_reports_osa, by = "missing_report")

missing_reports_osa <- 
  missing_reports_osa %>% 
  spread(report_id, missing_report) %>% 
  group_by(entity_name) %>% 
  summarize_all(funs(toString(na.omit(.)))) %>% 
  mutate_all(funs(replace(., . == 0, NA)))

missing_reports_osa[missing_reports_osa == ""] <-  NA

# Shift reports to the left:
missing_reports_osa2 <- 
  as.data.frame(
    t(
      apply(
        missing_reports_osa, 
        1, 
        function(x){return(c(x[!is.na(x)], x[is.na(x)]))})))

colnames(missing_reports_osa2) <- colnames(missing_reports_osa)

missing_reports_osa <- missing_reports_osa2

rm(report_year, reports__c, missing_reports_osa2)

for (j in 2:length(missing_reports_osa)) {
  
  colnames(missing_reports_osa)[j] <- paste("Auditor ", j - 1)
}
rm(j)
```

```{r}
# Difference between the Salesforce report and my report:
# a <- 
#   missing_reports_osa %>% distinct(entity_name)
# 
# b <- sf_auditor %>% distinct(`Entity Name`)
# 
# difference <- 
#   a %>% 
#   anti_join(b, by = c("entity_name" = "Entity Name"))
```

## Transparency

```{r}
missing_transp <- 
  dbGetQuery(
    odbc_salesforce,
    "SELECT 
      a.Name AS entity_name,
      t.Expenditure_Problem__c AS missing_exp,
      t.Revenue_Problem__c AS missing_rev,
      t.Wage_Problem__c AS missing_w2,
      t.CreatedDate AS created_date
    FROM Transparency_Reporting__c AS t
    JOIN Account AS a
    ON t.Account__c = a.Id
    WHERE t.IsDeleted = FALSE
    AND Status__c IN ('Delinquent_Enforced', 'Hold')
    AND Account__c IN (
      SELECT Id
      FROM Account
      WHERE RecordTypeId IN (
        SELECT Id
        FROM RecordType
        WHERE Name IN (
          'AOG', 'City', 'Community Reinvestment Agency', 'Conservation District',
          'County', 'District Health', 'Housing', 'Independent/Quasi State Entity',
          'Institution of Higher Education', 'Interlocal', 
          'Local and Special Service District', 'Mental Health', 'Non Profits', 
          'Redevelopment Agency/Project Area', 'School District or Charter School',
          'Town')))") %>% 
  mutate(created_date = as.Date(created_date)) %>% 
  
  # Filtering for the max created_date value may cause problems if any single entity
  # or group of entities has a more recent compliance report than any others, as
  # there will be entities missing from the filtered report. I want the max value
  # for each entity...
  # However, is this going to be an issue? Is it just something to be aware of?
  filter(created_date == max(created_date)) %>% 
  select(-created_date)

missing_transp <- 
  cSplit(
    missing_transp, 
    c("missing_exp", "missing_rev", "missing_w2"), 
    sep = ", ", 
    direction = "wide")
```

## Join Reports

```{r}
missing_reports <- 
  missing_reports_osa %>% 
  full_join(missing_transp, by = "entity_name")

report <-
  missing_reports %>%
  left_join(contact_info, by = c("entity_name"))

duplicate <- duplicated(report$entity_name)

report <- report[!duplicate, ]

```

```{r}
write_csv(report, "missing_reports_aug_2019.csv")
```

# DBMS Disconnection

```{r}
dbDisconnect()
```